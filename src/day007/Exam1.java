package day007;

public class Exam1 {
    public static void main(String[] args) {

        /* 생성자
        1. 생성자란?
        : 인스턴스(객체)화 할 때 사용되는 키워드
        2. 만드는 법
        : 클래스 내부에서 선언
            1. 클래스명과 동일하게 생성자명 정의한다.
               만약 다르면 메소드 취급 당하기 때문에 , 클래스명과 생성자명은 동일하게 해야 함.
            2. 오버로드
            : 매개변수의 **개수/타입/순서**에 따른 동일한 생성자/메소드를 여러 개 정의한 것. (매개변수명은 해당 안 함!)
              --> 즉: 개수, 타입, 순서가 다르면 (소괄호 안에 있는 게 다르면) 서로 다른 생성자로 인식해줌.)
                -> 오버로드(원래는 동일한 생성자 안 되는데 오버해서 동일한 생성자 가지게 하는 것.)
                    -> 본래 변수명과 메소드명은 동일한 {} 내 동일한 이름을 가질 수 없다.
                    - 인스턴스 사용 시 사용되는 키워드
                        +) 오버로딩(똑같은 거 다르게 가져옴. 조금 오버해서 추가적인 거 가져올 수 있다.)
        3. 목적
            1. 빠른 객체를 생성하기 위함.
                - 생성자 어려운 이유: 선택 사항이기 때문이다.
            2. 객체를 생성할 때 규칙을 생성하기 위함.
                - 장점: 협업 시 편리하다. / 단점: 복잡도가 증가한다.
        4. 생성자 종류
            1. 기본 생성자: 매개변수가 없는 생성자
                -> 클래스 내 생성자가 하나도 없으면 자동으로 실행할 때 생성된다.
            2. 생성자: 매개변수가 있는 생성자
                -> 메소드와 다르게 반환타입이 없다.
        5. 키워드
            1. this란?
            : 해당 메소드/생성자를 호출한 인스턴스 가리킴
                - 목적: 멤버변수명과 매개변수명이 동일할 때 식별 용도. 같은 이름 있을 때 식별하기 위함. this는 본인 가리키는 용도.
                - `this.멤버변수명`

        6. 생성자 사용*/
        Phone p1 = new Phone(); // new Phone(); 기본 생성자 호출
        p1.model = "갤럭시"; p1.color = "빨강"; p1.price = 10000000; // 실무에선 .찍어서 잘 안 함
        // * (실무) 객체 내 멤버변수에 직접적인 접근은 안 한다.
            // 왜냐면 직접접근하면 개발자가 개인정보를 다 확인할 수 있으니까...
                // 그니까 Phone은 볼 수 없고 Phone이 있다고 적힌 명세서만 제공됨.
            // 간접접근을 제공한다. 생성자나 메소드를 통해 접근한다. == < 캡슐화 >
        Phone p2 = new Phone("아이폰", "파랑"); // 매개변수를 갖는 생성자 호출
        // * 객체 재생성할 때 생성자 이용하여 멤버변수 초기화
        // * 매개변수 규칙: 인자값 타입과 매개변수 타입 일치해야 한다.
        Phone p3 = new Phone("갤럭시탭", "노랑", 20000);

    }
}
